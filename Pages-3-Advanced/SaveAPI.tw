:: SaveAPI [chapter menu] {"position":"2000,1800","size":"200,100"}
<h1>The Save APIs and Further Saving Configurations</h1>
While the Config APIs have [[configuration settings|Config-Saves]], it may not be enough for the customisation you may want to achieve. This is where the Save APIs come in.

The Save APIs can be grouped into different categories: Browsers (which will save in browser's caches), Disk, and Base64. The latter two will allow for import/export of saves from the user.
> ''Note:'' Browser saves (autosave/slot saves) are largely incompatible with Private Browsing Mode and Cookies/Cache blockers. Users may get an error message on start in those cases.
\
* [[Save Objects and Their Contents|SaveAPI-Objects]] 
* [[The Basic APIs of the Save Elements|SaveAPI-General]] 
* [[Managing the Save Slots|SaveAPI-Slots]] 
* [[Managing the Autosave Slot|SaveAPI-Autosave]]
* [[Managing Disk import and exports|SaveAPI-Disk]]
* [[Managing Base64 saves|SaveAPI-Base64]]
* [[Using Save-related Events|SaveAPI-Events]] 

<div id="link-menu">[[Back to the Start Menu|Start]]</div>

:: SaveAPI-Objects [page] {"position":"2000,1900","size":"100,100"}
<h1>Save Objects and Their Contents</h1>
When saved, a playthrough resides in a save object, with multiple property defined specifically for that playthrough.
> ''Note:'' the exported save (Save to Disk) is encoded by default

The save object has 6 properties:
* {{{date}}} (integer), the date the save was created
** this is indicated in [[milliseconds elpased since epoch|https://currentmillis.com/]]
* {{{desc}}} (string), the save's description
* {{{id}}}, the story's [[save ID|Config-Saves]]
* {{{metadata}}}, save metadata (end-user specified - JSON serializable)
* {{{state}}}, the marshaled story history 
** {{{expired}}} (optional), the array of expired moments (influenced by the [[Max State|Basic-API-Config]])
** {{{history}}}, the arrays of moment objects 
*** {{{pull}}} (optional), current pull count of SugarCube's seedable PRNG
*** {{{title}}}, the title of the associated passage 
*** {{{variables}}}, the current variable store object ({{{State.variables}}})
** {{{index}}}, the index of active moments 
** {{{seed}}} (optional), seed of SugarCube's seedable PRNG
* {{{type}}}, the save's type.
** defined in {{{Save.Type}}} as [[Base64|SaveAPI-Base64]], [[Disk|SaveAPI-Disk]], and browser saves ([[autosaves|SaveAPI-Autosave]] or [[slot|SaveAPI-Slots]])
* {{{version}}}, save [[version|Config-Saves]]
\
> ''Note:'' adding additional properties is not recommended. Instead use the metadata property.

<div id="link-menu">[[Back to the Save APIs Menu|SaveAPI]] - [[Back to the Start Menu|Start]]</div>

:: SaveAPI-General [page] {"position":"2100,1900","size":"100,100"}
<h1>The Basic APIs of the Save Elements</h1>
The APIs below handle Browser saves, both auto and slot saves.

TODO:
                {Save.browser.size} -> variable 
                console.log(`There are currently ${Save.browser.size} browser saves`);

if (Save.browser.size > 0) {
	/* Browser saves exist. */
}

if (Save.browser.size === 0) {
	/* No browser saves exist. */
}

            Save.browser.continue()
asic usage

Load the most recent browser save, only handling failure. This should be sufficient in the majority of cases.

if (Save.browser.size > 0) {
	Save.browser.continue()
		.catch(error => {
			/* Failure.  Handle the error. */
			console.error(error);
			UI.alert(error);
		});
}
else {
	/* No browser saves exist. */
}

Load the most recent browser save, handling both success and failure.

if (Save.browser.size > 0) {
	Save.browser.continue()
		.then(() => {
			/* Success.  Do something special. */
		})
		.catch(error => {
			/* Failure.  Handle the error. */
			console.error(error);
			UI.alert(error);
		});
}
else {
	/* No browser saves exist. */
}
            Save.browser.isEnabled()
if (Save.browser.isEnabled()) {
	/* Some browser saves are enabled. */
}
\
<h3>The General Save APIs</h3>\
\
<h4>{{{Save.browser.clear()}}}</h4>\
This API will delete all slot saves and the autosave (if enabled). This is the code behind the //Delete All// button in the Save Popup.
{{{
    Save.browser.clear()
}}}
[ Remove from here ]
\
<h4>{{{Save.get()}}}</h4>\ ????
This API will return the saves object (all in-browser saves).
{{{
    Save.get()
}}}
\
<h4>{{{Save.ok() -> Save.browser.isEnabled()}}}</h4>\
This API will check whether the project includes slot saves and autosaves.
{{{
    Save.ok()

    if (Save.ok()) {
	    /* Code to manipulate saves. */
    }

    <<if Save.ok()>> ... <</if>>
}}}
\
<h3>Importing and Exporting to Disk</h3>\
The following APIs are the ones used in the Save Popup, with the //Export to Disk// and //Load from Disk// buttons.
<center> <<link "Export to Disk">><<run Save.export()>><</link>> | <<link "Load From Disk">>
        <<script>>
        jQuery(document.createElement('input'))
            .prop('type', 'file')
            .on('change', Save.import)
            .trigger('click');
        <</script>>
    <</link>></center>
\
[should be a whole new chapter]
<h4>{{{Save.export()-> Save.disk.save()}}}</h4>\
This API will save the current playthrough (or loaded save) to the device's disk. The file is saved under the extension {{{.save}}}.
{{{
    Save.export([filename [, metadata]])
}}}
The API has 2 parameters:
* {{{filename}}} (optional), the base filename of the save (slugified), with the datestamp and file extension appended automatically.
** default is the story's title (slugified)
* {{{metadata}}} (optional), the date to be stored in the save object's [[metadata|SaveAPI-Objects]] property.
\
> //Examples://
{{{
    Save.export()
→ default filename + no metadata

    Save.export("Sweet Stuff 2")
→ custom filename + no metadata
  → sweet-stuff-2-{datestamp}.save

    Save.export(null, someMetadata)
→ default filename + some metadata

    Save.export("Sweet Stuff 2", someMetadata)
→ custom filename + some metadata
  → sweet-stuff-2-{datestamp}.save
}}}
\
<h4>{{{Save.import() -> Save.disk.load()}}}</h4>\
This API will load a save file from disk.
> ''Note:'' this must be called by the change vent handler of an {{{<input type="file">}}} element.
{{{
    Save.import(event)
}}}
This API has 1 parameter:
* {{{event}}}, the event object passed to the change event handler of the associated {{{<input type="file">}}} element.
\
> //Basic usage example from the Documentation://
{{{
→ Assuming you're creating a file input something like the following
    var input  = document.createElement('input');
    input.type = 'file';
    input.id   = 'saves-import-file';
    input.name = 'saves-import-file';

→ Set up Save.import() as the event handler for when a file has been chosen
    jQuery(input).on('change', Save.import);
}}}
> //More Complex Documentation Example//
{{{
→ Assuming you're creating a file input something like the following
    var input  = document.createElement('input');
    input.type = 'file';
    input.id   = 'saves-import-file';
    input.name = 'saves-import-file';

→ Set up a custom event handler for when a file has been chosen, which will call Save.import()
    jQuery(input).on('change', function (ev) {
        /* You must pass in the event when calling Save.import() manually */
        Save.import(ev);

        /* Put anything else you needed to do here */
    });
}}}
> //Code of the Interactive Example://
{{{
    <<link "Load From Disk">>
        <<script>>
        jQuery(document.createElement('input'))
            .prop('type', 'file')
            .on('change', Save.import)
            .trigger('click');
        <</script>>
    <</link>>
}}}
\
<h3>Serialize the Save File</h3>\
\
<h4>{{{Save.serialize()}}}</h4>\
This API will return a save as a serialized string (or null if saving is now allowed)
{{{
    Save.serialize([metadata])
}}}
It has 1 parameter: 
* {{{metadata}}} (optional), the data to be stored as metadata (JSON-serializable)
\
> //Examples://
{{{
→ Serialize a save with no metadata
    const myGameState = Save.serialize();
    if (myGameState === null) {
        /* Failure.  You've disallowed saving. */
    }

→ Serialize a save with metadata someMetadata
    const myGameState = Save.serialize(someMetadata);
    if (myGameState === null) {
        /* Failure.  You've disallowed saving. */
    }
}}}
\
<h4>{{{Save.deserialize()}}}</h4>\
This API will deserialize the given save string, created with {{{Save.serialize()}}}, and load the save. It will also return the bundled metadata (if defined), or NULL if the save could not be deserialize and loaded.
{{{
    Save.deserialize(saveStr)
}}}
It has 1 parameter:
* {{{saveStr}}}, the serialized save string.
\
> //Examples://
{{{
→ Deserialize a save with no metadata
    const loadResult = Save.deserialize(myGameState);
    if (loadResult === null) {
        /* Failure.  An error was displayed to the player. */
    }

→ Deserialize a save with metadata
    const loadResult = Save.deserialize(myGameState);
    if (loadResult !== null) {
        /* Success.  Do something with loadResult, which contains the metadata. */
    }
    else {
        /* Failure.  An error was displayed to the player. */
    }
}}}

<div id="link-menu">[[Back to the Save APIs Menu|SaveAPI]] - [[Back to the Start Menu|Start]]</div>

:: SaveAPI-Slots [page] {"position":"2000,2000","size":"100,100"}
<h1>Managing the Save Slots</h1>
The APIs below will allow you to manage the available save slots. These can be useful when providing returning players to a quick link to load their saves, or creating your own Save page.
\
<h3>{{{Save.slots.length}}}</h3>\
This API will return the total number of available slots. It will be influenced by the [[Config API|Basic-API-Config]].
{{{
    Save.slots.length
}}}
\
<h3>{{{Save.slots.count()}}}</h3>\
This API will count the number of filled save slots.
{{{
    Save.slots.count()
}}}
> //Example://
{{{
    <<if Save.slots.count() gt 0>>
        <<link "Load Save">>
            <<run UI.saves()>>
        <</link>>
    <</if>>
}}}
\
<h3>{{{Save.slots.delete()}}}</h3>\
This API will delete a save from the given slot. This is what is behind the //Delete// buttons on the Save Popup.
{{{
    Save.slots.delete(slot)
}}}
It has 1 parameter:
* {{{slot}}}, the save slot index (0-based)
\
> //Example://
{{{
    Save.slots.delete(5)  
→ Deletes the sixth slot save
}}}
\
<h3>{{{Save.slots.get()}}}</h3>\
This API will return a save object from the given slot or NULL if there is no save.
{{{
    Save.slots.get(slot)
}}}
It has 1 parameter:
* {{{slot}}}, the save slot index (0-based)
\
> //Example://
{{{
    Save.slots.get(5)  
→ Returns the sixth slot save
}}}
\
<h3>{{{Save.slots.has()}}}</h3>\
This API will check whether the given slot is filled.
{{{
    Save.slots.has(slot)
}}}
It has 1 parameter:
* {{{slot}}}, the save slot index (0-based)
\
> //Examples://
{{{
    Save.slots.has(5)  
→ checks the sixth slot save

    if (Save.slots.has(5)) {
        /* Code to manipulate the sixth slot save. */
    }
}}}
\
<h3>{{{Save.slots.isEmpty()}}}</h3>\
This API will check whether there are any filled slots. It will return with a //true// value if all slots are empty, and a //false// one if at least one slot is filled.
{{{
    Save.slots.isEmpty()
}}}
\
<h3>{{{Save.slots.load()}}}</h3>\
This API will load a save from the given slot. This is the code behind the //Load// buttons in the Save Popup.
{{{
    Save.slots.load(slot)
}}}
It has 1 parameter:
* {{{slot}}}, the save slot index (0-based)
\
> //Example://
{{{
    Save.slots.load(5)  
→ Loads the sixth slot save
}}}
\
<h3>{{{Save.slots.ok()}}}</h3>\
This API will check whether the slots saves are available.
{{{
    Save.slots.ok()

    if (Save.slots.ok()) {
        /* Code to manipulate slot saves. */
    }
}}}
\
<h3>{{{Save.slots.save()}}}</h3>\
This API will save to the given slot. This is the code behind the //Save// buttons in the Save Popup.
{{{
    Save.slots.save(slot [, title [, metadata]])
}}}
It has 3 parameters:
* {{{slot}}}, the save slot index (0-based)
* {{{title}}} (optional), the title of the save
** if omitted or NULL, it defaults to the passage's description 
* {{{metadata}}} (optional), the data to be stored as metadata (JSON-serializable)
\
> //Examples://
{{{
    Save.slots.save(5)
→ Save to the sixth slot 
  + default title and no metadata

    Save.slots.save(5, "Midgar")
→ Save to the sixth slot 
  + title "Midgar" and no metadata

    Save.slots.save(5, null, someMetadata)
→ Save to the sixth slot 
  + default title and metadata someMetadata

    Save.slots.save(5, "Midgar", someMetadata)
→ Save to the sixth slot 
  + title "Midgar" and metadata someMetadata
}}}

<div id="link-menu">[[Back to the Save APIs Menu|SaveAPI]] - [[Back to the Start Menu|Start]]</div>

:: SaveAPI-Autosave [page] {"position":"2100,2000","size":"100,100"}
<h1>Managing the Autosave Slot</h1>
The APIs below will allow you to manage the autosave slot. These can be useful when providing returning players to a quick link to load their autosave.


TODO: Save.browser.auto.size
Save.browser.auto.get(index)
\
<h3>Save.browser.auto.delete(index) and  Save.browser.auto.clear() </h3>\
This API will delete the autosave.
 Save.browser.auto.clear()  -> all of them 
 Other is just one
{{{
    Save.autosave.delete()
}}}
\
<h3>{{{Save.browser.auto.get(index)}}}</h3>\
This API will return the save object from the autosave slot, or NULL.
{{{
    Save.autosave.get()
}}}
\
<h3>{{{Save.browser.auto.has()}}}</h3>\
This API will check whether the autosave is filled.
{{{
    Save.autosave.has()

    if (Save.autosave.has()) {
        /* Code to manipulate the autosave. */
    }
}}}
\
<h3>{{{Save.browser.auto.load()}}}</h3>\
This API will load the autosave (if filled).
{{{
    Save.autosave.load()
}}}
\
<h3>{{{Save.browser.auto.isEnabled()}}}</h3>\
This API will check whether the autosave is available.
{{{
    Save.autosave.ok()

    if (Save.autosave.ok()) {
        /* Code to manipulate the autosave. */
    }
}}}
\
<h3>{{{Save.browser.auto.save()}}}</h3>\
This API will save to the autosave slot.
{{{
    Save.autosave.save([title [, metadata]])
}}}
It has 3 parameters:
* {{{title}}} (optional), the title of the save
** if omitted or NULL, it defaults to the passage's description 
* {{{metadata}}} (optional), the data to be stored as metadata (JSON-serializable)
\
> //Examples://
{{{
    Save.autosave.save()
→ Save to the autosave slot 
  + default title and no metadata

    Save.autosave.save("Midgar")
→ Save to the autosave slot
  + title "Midgar" and no metadata

    Save.autosave.save(null, someMetadata)
→ Save to the autosave slot
  + default title and metadata someMetadata

    Save.autosave.save("Midgar", someMetadata)
→ Save to the autosave slot 
  + title "Midgar" and metadata someMetadata
}}}

<div id="link-menu">[[Back to the Save APIs Menu|SaveAPI]] - [[Back to the Start Menu|Start]]</div>


:: SaveAPI-Events [page] {"position":"2000,2100","size":"100,100"}
<h1>Using Save-related Events</h1>
\
<h3>Events during Save Load</h3>\
\
<h4>{{{Save.onLoad.add()}}}</h4>\
This API will perform any required processing before a save is loaded, like upgrading out-of-date save data. If the defined function encounters an unrecoverable problem during processing, it will give an error to the player and terminate the loading of the save.
{{{
    Save.onLoad.add(handler)
}}}
It has 1 parameter: 
* {{{handler}}}, the function to be executed when loading a save
** {{{save}}}, the save object to be processed
\
> //Example://
{{{
    Save.onLoad.add(function (save) {
        /* code to process the save object before it's loaded */
    });

→ Updading old saves to be compatible:
    Save.onLoad.add(function (save) {
        const history = save.state.history;
        if (save.version < 14) {
            /* 
                Code to fix all saves upto version 14 
            */
            save.version = 14;
            /* Updating the save file's version */
        }
    });
}}}
> ''Note:'' the {{{save.version}}} will be defined with the relevant [[Config API|Config-Saves]]
\
<h4>{{{Save.onLoad.clear()}}}</h4>\
This API will delete all currently defined on-load handlers.
{{{
    Save.onLoad.clear()
}}}
\
<h4>{{{Save.onLoad.delete()}}}</h4>\
This API will delete the specified on-load handler.
{{{
    Save.onLoad.delete(handler)
}}}
It has 1 parameter:
* {{{handler}}}, the function to be executed when loading a save
> //Assuming that:// {{{myOnLoadHandler = function (save) { /* handler */}}}}
{{{
    Save.onLoad.delete(myOnLoadHandler);
}}}
\
<h4>{{{Save.onLoad.size}}}</h4>\
This API will give the number of currently registered on-load handlers.
{{{
    Save.onLoad.size
}}}
> //Example://
{{{
    console.log('There are %d onLoad handlers registered.', Save.onLoad.size);
}}}
\
<h3>Events during Saving</h3>\
\
<h4>{{{Save.onSave.add()}}}</h4>\
This API will perform any required processing before data is saved. It can be useful when wanting to run different code depending on the type of save (auto/slot/disk), or formatting names of saves.
{{{
    Save.onSave.add(handler)
}}}
It has 1 parameter: 
* {{{handler}}}, the function to be executed when saving a save
** {{{save}}}, the save object to be processed
** {{{details}}}, the save operation details object
*** {{{type}}}, representing what cause the save ({{{'autosave'}}}, {{{'disk'}}}, {{{'serialize'}}}, {{{'slot'}}})
\
> //Examples://
{{{
    Save.onSave.add(function (save) {
        /* code to process the save object before it's saved */
    });

    Save.onSave.add(function (save, details) {
        switch (details.type) {
            case 'autosave': {
                /* Code processed for autosaves */
                break;
            }
            case 'disk': {
                /* Code processed for disk saves */
                break;
            }
            case 'serialize': {
                /* Code processed for serialized saves */
                break;
            }
            default: { 
                /* Code processed for slot saves */
                break;
            }
        }
    });

}}}
> ''Note:'' I use this API to format how saves and autosaves are named in my [[Setting Template|https://manonamora.itch.io/twine-sugarcube-templates]].
\
<h4>{{{Save.onSave.clear()}}}</h4>\
This API will delete all currently defined on-save handlers.
{{{
    Save.onSave.clear();
}}}
\
<h4>{{{Save.onSave.delete()}}}</h4>\
This API will delete the specified on-save handler.
{{{
    Save.onSave.delete(handler)
}}}
It has 1 parameter:
* {{{handler}}}, the function to be executed when loading a save
> //Assuming that:// {{{myOnLoadHandler = function (save, details) { /* handler */}}}}
{{{
    Save.onSave.delete(myOnLoadHandler);
}}}
\
<h4>{{{Save.onSave.size}}}</h4>\
This API will give the number of currently registered on-save handlers.
{{{
    Save.onSave.size
}}}
> //Example://
{{{
    console.log('There are %d onSave handlers registered.', Save.onSave.size);
}}}

<div id="link-menu">[[Back to the Save APIs Menu|SaveAPI]] - [[Back to the Start Menu|Start]]</div>

:: SaveAPI-Disk [page]
<h1>Managing Disk import and exports</h1>
Save.disk.export(filename)

Exports all existing browser saves as a bundle to disk, which may be restored via Save.disk.import().
History:

    v2.37.0: Introduced.

Parameters:

    filename: (string) The base filename of the browser save export, which gets slugified to remove most symbols. Appended to this is a datestamp (format: YYYMMDD-hhmmss) and the file extension .savesbundle—e.g., "The Scooby Chronicles" would result in the full filename: the-scooby-chronicles-{datestamp}.savesbundle.

Returns: none
Throws:

An Error instance.
Examples:

Export all saves as a bundle with a base filename, handling failure.

try {
	Save.disk.export('The 6th Fantasy');
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}

 Save.disk.import(event) → Promise

Imports a saves bundle from disk, created via Save.disk.export().

Note: This method must be used as, or be called by, the change event handler of an <input type="file"> element.

Warning: All existing browser saves will be deleted as part of restoring the exported save bundle.
History:

    v2.37.0: Introduced.

Parameters:

    event: (Event) The event object that was passed to the change event handler of the associated <input type="file"> element.

Returns:

A Promise that simply resolves, or rejects with an error if the browser saves bundle could not be imported.
Throws: none
Examples:
Basic usage

Import the saves bundle from disk, only handling failure. This should be sufficient in the majority of cases.

jQuery(document.createElement('input'))
	.prop({
		id   : 'saves-import-file',
		name : 'saves-import-file',
		type : 'file'
	})
	.on('change', ev => {
		// You must provide the event to Save.disk.import()
		Save.disk.import(ev)
			.catch(error => {
				/* Failure.  Handle the error. */
				console.error(error);
				UI.alert(error);
			});
	});

Import the saves bundle from disk, handling both success and failure.

jQuery(document.createElement('input'))
	.prop({
		id   : 'saves-import-file',
		name : 'saves-import-file',
		type : 'file'
	})
	.on('change', function (ev) {
		// You must provide the event to Save.browser.import()
		Save.disk.import(ev)
			.then(() => {
				/* Success.  Do something special. */
			})
			.catch(error => {
				/* Failure.  Handle the error. */
				console.error(error);
				UI.alert(error);
			});
	});

 Save.disk.load(event) → Promise

Loads the given save from disk, created via Save.disk.save().

Note: This method must be used as, or be called by, the change event handler of an <input type="file"> element.

Warning: Saves cannot be loaded during startup and any attempt to do so will cause an error.
History:

    v2.37.0: Introduced.

Parameters:

    event: (Event) The event object that was passed to the change event handler of the associated <input type="file"> element.

Returns:

A Promise that resolves with the save's metadata (any), or rejects with an error if the save could not be loaded.
Throws: none
Examples:
Basic usage

Load the disk save. This should be sufficient in the majority of cases.

jQuery(document.createElement('input'))
	.prop({
		id   : 'saves-disk-load-file',
		name : 'saves-disk-load-file',
		type : 'file'
	})
	.on('change', ev => {
		// You must provide the event to Save.disk.load()
		Save.disk.load(ev)
			.then(metadata => {
				Engine.show();
			})
			.catch(error => {
				/* Failure.  Handle the error. */
				console.error(error);
				UI.alert(error);
			});
	});

As a self-contained button using macros

<<button "Load From Disk">>
	<<script>>
	jQuery(document.createElement('input'))
		.prop('type', 'file')
		.on('change', ev => {
			// You must provide the event to Save.disk.load()
			Save.disk.load(ev)
				.then(metadata => {
					Engine.show();
				})
				.catch(error => {
					/* Failure.  Handle the error. */
					console.error(error);
					UI.alert(error);
				});
		})
		.trigger('click');
	<</script>>
<</button>>

 Save.disk.save(filename [, metadata])

Saves the current story state to disk, which may be restored via Save.disk.load().
History:

    v2.37.0: Introduced.

Parameters:

    filename: (string) The base filename of the disk save, which gets slugified to remove most symbols. Appended to this is a datestamp (format: YYYMMDD-hhmmss) and the file extension .save—e.g., "The Scooby Chronicles" would result in the full filename: the-scooby-chronicles-{datestamp}.save.
    metadata: (optional, any) The data to be stored in the save object's metadata property. Must be JSON-serializable.

Returns: none
Throws:

An Error instance.
Examples:

Save with a base filename and no metadata, handling failure.

try {
	Save.disk.save("The 6th Fantasy");
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}

Save with a base filename and metadata, handling failure.

try {
	const saveMetadata = {
		chars : ['Celes', 'Locke', 'Edward'],
		gold  : 2345
	};
	Save.disk.save("The 6th Fantasy", saveMetadata);
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}

:: SaveAPI-Base64 [page]
<h1>Managing Base64 saves</h1>
Save.base64.export() → string

Exports all existing browser saves as a bundle to a Base64 string, which may be restored via Save.base64.import().
History:

    v2.37.0: Introduced.

Parameters: none
Returns: none
Throws:

An Error instance.
Examples:

Export all saves as a bundle, handling failure.

try {
	const base64Save = Save.base64.export();
	/* Do something with the saves bundle. */
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}

 Save.base64.import(bundle) → Promise

Imports the given Base64 saves bundle string, created via Save.base64.export().

Warning: All existing browser saves will be deleted as part of restoring the exported save bundle.
History:

    v2.37.0: Introduced.

Parameters:

    bundle: (string) The Base64 saves bundle string.

Returns:

A Promise that simply resolves, or rejects with an error if the browser saves bundle could not be imported.
Throws: none
Examples:
Basic usage

Import the saves bundle, only handling failure. This should be sufficient in the majority of cases.

Save.base64.import(base64Bundle)
	.catch(error => {
		/* Failure.  Handle the error. */
		console.error(error);
		UI.alert(error);
	});

Import the saves bundle, handling both success and failure.

Save.base64.import(base64Bundle)
	.then(() => {
		/* Success.  Do something special. */
	})
	.catch(error => {
		/* Failure.  Handle the error. */
		console.error(error);
		UI.alert(error);
	});

 Save.base64.load(save) → Promise

Loads the given Base64 save string, created via Save.base64.save().

Warning: Saves cannot be loaded during startup and any attempt to do so will cause an error.
History:

    v2.37.0: Introduced.

Parameters:

    save: (string) The Base64 save string.

Returns:

A Promise that resolves with the save's metadata (any), or rejects with an error if the save could not be loaded.
Throws: none
Examples:
Basic usage

Load the save string. This should be sufficient in the majority of cases.

Save.base64.load(base64Save)
	.then(metadata => {
		Engine.show();
	})
	.catch(error => {
		/* Failure.  Handle the error. */
		console.error(error);
		UI.alert(error);
	});

 Save.base64.save([metadata]) → string

Saves the current story state as a Base64 string.
History:

    v2.37.0: Introduced.

Parameters:

    metadata: (optional, any) The data to be stored in the save object's metadata property. Must be JSON-serializable.

Returns:

A Base64 save string.
Throws:

An Error instance.
Examples:
Basic usage

Save without metadata, handling failure.

try {
	const base64Save = Save.base64.save();
	/* Do something with the save. */
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}

Save with metadata, handling failure.

try {
	const saveMetadata = {
		chars : ['Celes', 'Locke', 'Edward'],
		gold  : 2345
	};
	const base64Save = Save.base64.save(saveMetadata);
	/* Do something with the save. */
}
catch (error) {
	/* Failure.  Handle the error. */
	console.error(error);
	UI.alert(error);
}
